/*
 *  libgnomebt -- GNOME Bluetooth libraries
 *  Copyright (C) 2003-2004 Edd Dumbill
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
 */
requires 2.0.0

%{
#include "gnomebt-permissiondialog.h"
%}

%h{
#include <glib.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gtk/gtk.h>
#include <gnome.h>
#include "gnomebt-controller.h"
#include "gnomebt-icons.h"
%}

%{
static void remember_cb (GtkToggleButton *button, gpointer user_data);
%}

class Gnomebt:PermissionDialog from Gtk:Message:Dialog {
    private GtkWidget *okbutton;
    private GtkWidget *cancelbutton;
    private GtkWidget *label;
    private GtkWidget *rememberbutton;

    private GdkPixbuf *icon = { gnomebt_icon (); }
        destroywith g_object_unref;

    private gboolean remember = FALSE;

    private gulong remember_cb;

    public GnomebtController *btmanager;

    init (self)
    {
    }

    private void
    initialise_gui (self, const gchar *bdaddr, const gchar *title,
        const gchar *explanation, const gchar *alwaystext)
	{
	gchar *title_markup, *title_device;
        gchar *exp;
        gchar *dname;
        GtkWidget *hbox,*vbox,*img;
	GValue value = { 0, };

        /* border & spacing */
        hbox = GTK_WIDGET (gtk_hbox_new (FALSE, 12));
        gtk_container_set_border_width (GTK_CONTAINER (hbox), 6);

        gtk_container_add (GTK_CONTAINER(GTK_DIALOG(self)->vbox), hbox);

        vbox = GTK_WIDGET (gtk_vbox_new (FALSE, 12));

        gtk_window_set_icon (GTK_WINDOW (self), self->_priv->icon);

        /* image */
	g_value_init (&value, GTK_TYPE_INT);
	g_value_set_int (&value, GTK_MESSAGE_QUESTION);
	g_object_set_property (G_OBJECT (self), "message-type", &value);

        /* fill up hbox */
        gtk_container_add (GTK_CONTAINER(hbox), vbox);

        /* make widgets */
        gtk_dialog_add_buttons (GTK_DIALOG(self),
            GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
            NULL);

        self->_priv->okbutton = GTK_WIDGET (gtk_dialog_add_button (
            GTK_DIALOG(self), GTK_STOCK_OK, GTK_RESPONSE_OK));

        gtk_dialog_set_default_response (GTK_DIALOG(self),
            GTK_RESPONSE_OK);

        gtk_window_set_title (GTK_WINDOW(self),"");

        gtk_window_set_position (GTK_WINDOW(self),
            GTK_WIN_POS_MOUSE);

        dname = gnomebt_controller_get_device_preferred_name (self->btmanager, bdaddr);

        if (!title) {
            title_device = g_strdup_printf
	        (_("Allow Bluetooth device '%s' to connect?"),
                (dname != NULL ? dname : bdaddr));
	} else{
	    title_device = g_strdup_printf
	        (title, (dname != NULL ? dname : bdaddr));
	}

	title_markup = g_strdup_printf ("<span weight='bold' size='larger'>%s</span>", title_device);
	g_free (title_device);
	g_free (dname);

        gtk_message_dialog_set_markup (GTK_MESSAGE_DIALOG (self), title_markup);
	g_free (title_markup);

        gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (self),
	    "%s", explanation ? explanation :
	    _("An external device is attempting to connect to your computer via Bluetooth. You must decide if you want to accept the connection."));

        /* remember this button */

        self->_priv->rememberbutton = GTK_WIDGET (
            gtk_check_button_new_with_mnemonic (alwaystext ? alwaystext : 
                _("_Always allow this device to connect.")));

        gtk_container_add (GTK_CONTAINER (vbox),
            self->_priv->rememberbutton);

        gtk_widget_show_all (GTK_WIDGET(self));
	}

    public
    GnomebtPermissionDialog *
    new (GnomebtController *ctl, const gchar *bdaddr,
        const gchar *title, const gchar *explanation,
        const gchar *alwaystext)
    {
        GnomebtPermissionDialog *dlg = GNOMEBT_PERMISSIONDIALOG(GET_NEW);
        dlg->btmanager = ctl;
        gnomebt_permissiondialog_initialise_gui (dlg, bdaddr,
            title, explanation, alwaystext);
        g_signal_connect (
            GTK_OBJECT (dlg->_priv->rememberbutton),
            "toggled", G_CALLBACK (remember_cb), (gpointer) dlg);
        return dlg;
    }

    public
    gboolean
    remember (self)
    {
        return self->_priv->remember;
    }

}

%{
static void
remember_cb (GtkToggleButton *button, gpointer user_data)
{
    GnomebtPermissionDialog *dlg = GNOMEBT_PERMISSIONDIALOG (user_data);
    dlg->_priv->remember = gtk_toggle_button_get_active (button);
}
%}
