/*
 * libgnomebt -- GNOME Bluetooth libraries
 * Copyright (C) 2003-2004 Edd Dumbill
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
 */

requires 2.0.0

%{
#include <gconf/gconf-client.h>
#include "gnomebt-chooser.h"

enum 
{
    DEV_NAME_COLUMN,
	DEV_NUM_COLUMN,
    DEV_NUM_COLUMNS
};

static void treeview_cb (GtkTreeSelection *sel, gpointer data);
static void response_cb (GtkDialog *d, gint arg, gpointer userdata);
static void device_found_cb (GnomebtController *bc, gchar* device,
    gchar* name, gpointer data);
static void status_cb (GnomebtController *bc, gint field, gpointer data);
/*static gboolean timeout_cb (gpointer data); */

#define GNOMEBT_RESPONSE_SCAN  2
%}

%h{
#include <glib.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gtk/gtk.h>
#include <gnome.h>
#include "gnomebt-controller.h"
#include "gnomebt-spinner.h"
%}

class Gnomebt:Chooser from Gtk:Dialog {
    private GtkListStore *devstore = { 
        gtk_list_store_new (DEV_NUM_COLUMNS, G_TYPE_STRING, G_TYPE_UINT); }
        destroywith g_object_unref;

    private GSList *list = { NULL; }
        destroy { if (VAR) gnomebt_device_desc_list_free (VAR); };

    private gint cur_device = -1;
    private GtkWidget *okbutton;
    private GtkWidget *scanbutton;
    private gint response = 0;
    private GtkWidget *devtreeview;
    private GnomebtSpinner *spin;
    private guint timeout_stop = 0;
    private gulong discovery_cb = 0 
        destroy {
            if (discovery_cb) {
                GnomebtChooser *self= GNOMEBT_CHOOSER (obj_self);
                g_signal_handler_disconnect (
                    (gpointer)(self->btmanager),
                    discovery_cb);
            }
        };
    private gulong status_cb = 0 
        destroy {
            if (status_cb) {
                GnomebtChooser *self= GNOMEBT_CHOOSER (obj_self);
                g_signal_handler_disconnect (
                    (gpointer)(self->btmanager),
                    status_cb);
            }
        };
    public GnomebtController *btmanager;

    init (self)
	{
        GtkWidget *sw;
        GtkTreeSelection *select;

        /* initialise ui */   

        self->_priv->scanbutton = GTK_WIDGET (gtk_dialog_add_button (
            GTK_DIALOG(self), GTK_STOCK_REFRESH, GNOMEBT_RESPONSE_SCAN));

        self->_priv->okbutton = GTK_WIDGET (gtk_dialog_add_button (
            GTK_DIALOG(self), GTK_STOCK_OK, GTK_RESPONSE_OK));
        gtk_widget_set_sensitive (self->_priv->okbutton, FALSE);

        gtk_dialog_add_buttons (GTK_DIALOG(self),
            GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
            NULL);

        gtk_dialog_set_default_response (GTK_DIALOG(self),
            GTK_RESPONSE_CANCEL);

        gtk_window_set_title (GTK_WINDOW(self),
            _("Choose Bluetooth device"));

        gtk_window_set_position (GTK_WINDOW(self),
            GTK_WIN_POS_MOUSE);

        /* response callback */
        g_signal_connect (GTK_OBJECT (self), "response", 
             G_CALLBACK (response_cb), (gpointer) self);

        /* border & spacing */

        gtk_box_set_spacing (
            GTK_BOX (GTK_DIALOG(self)->vbox),
            6);

        /* make the scrolled window */

        sw = GTK_WIDGET (gtk_scrolled_window_new (NULL, NULL));
        gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW(sw),
            GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
        gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW(sw),
            GTK_SHADOW_IN);
        
        /* make the treeview */

        self->_priv->devtreeview = gtk_tree_view_new ();
        gtk_tree_view_set_model (GTK_TREE_VIEW(self->_priv->devtreeview),
            gtk_tree_model_sort_new_with_model (
                GTK_TREE_MODEL (self->_priv->devstore)));
        select = gtk_tree_view_get_selection (
            GTK_TREE_VIEW (self->_priv->devtreeview));
        gtk_tree_selection_set_mode (select, GTK_SELECTION_SINGLE);
        gtk_tree_view_set_headers_visible (
            GTK_TREE_VIEW (self->_priv->devtreeview), FALSE);

        /* set selection callback */

        g_signal_connect(G_OBJECT(select), "changed",
			G_CALLBACK(treeview_cb), (gpointer)self);

        /* add renderer to tree */
        gnomebt_chooser_add_text_renderer (self, DEV_NAME_COLUMN,
            _("Device"));

        /* add the treeview and show all widgets */

        gtk_container_add (GTK_CONTAINER(sw), self->_priv->devtreeview);
        gtk_container_add (GTK_CONTAINER(GTK_DIALOG(self)->vbox), sw);
        gtk_widget_show_all (GTK_WIDGET(self));
	}

    public
    GnomebtChooser *
    new (GnomebtController *ctl)
    {
        GnomebtChooser *chooser = GNOMEBT_CHOOSER(GET_NEW);
        chooser->btmanager = ctl;
        /* fill up with data */
        gnomebt_chooser_populate_device_list (chooser);

        chooser->_priv->discovery_cb = g_signal_connect_after (
            G_OBJECT(ctl), "device_name",
            G_CALLBACK(device_found_cb), (gpointer)chooser);

        chooser->_priv->status_cb = g_signal_connect_after (
            G_OBJECT(ctl), "status_change",
            G_CALLBACK(status_cb), (gpointer)chooser);

        return chooser;
    }

    public
    gint
    get_response (self)
    {
        return self->_priv->response;
    }

    public
    gchar *
    get_bdaddr (self)
    {
        if (self->_priv->cur_device >= 0) {
            GnomebtDeviceDesc *dd=(GnomebtDeviceDesc*)
                g_slist_nth(self->_priv->list, self->_priv->cur_device)->data;
            return g_strdup (dd->bdaddr);
        } else {
            return NULL;
        }
    }

    public
    void
    start_scan (self)
    {
        /* commence an async scan */
        gtk_widget_set_sensitive (GTK_WIDGET(self->_priv->scanbutton), FALSE);
        btctl_controller_discover_async (BTCTL_CONTROLLER(self->btmanager));
    }

    private
    void
    add_text_renderer (self, int colno, gchar *label)
    {
        GtkCellRenderer *renderer;
        GtkTreeViewColumn *column;
        GtkTreeView *tv = GTK_TREE_VIEW (self->_priv->devtreeview);

        renderer = gtk_cell_renderer_text_new ();
        column = gtk_tree_view_column_new_with_attributes (
            label, renderer, "text", colno, NULL);
        gtk_tree_view_append_column (tv, column);
    }

    private
    void
    populate_device_list (self)
    {
        guint i=0;
        GtkTreeIter iter;
        GSList *item;

        if (self->_priv->list)
            gnomebt_device_desc_list_free (self->_priv->list);
        self->_priv->list = gnomebt_controller_known_devices (
            self->btmanager);

        gtk_list_store_clear (self->_priv->devstore);
        for (item=self->_priv->list, i=0; item!=NULL;
            item=g_slist_next(item), i++) {
            GnomebtDeviceDesc *dd=(GnomebtDeviceDesc*)item->data;
            gtk_list_store_append(self->_priv->devstore, &iter);
            gtk_list_store_set(self->_priv->devstore, &iter,
				DEV_NAME_COLUMN, dd->name,
				DEV_NUM_COLUMN, i,
				-1);
        }
        gtk_tree_sortable_set_sort_column_id (
            GTK_TREE_SORTABLE(self->_priv->devstore),
            DEV_NAME_COLUMN, GTK_SORT_ASCENDING);
    }
}

%{
static void
treeview_cb (GtkTreeSelection *sel, gpointer data)
{
	GtkTreeIter iter;
	GtkTreeModel *model;
	GnomebtChooser *chooser=(GnomebtChooser *)data;

	if (gtk_tree_selection_get_selected(sel, &model, &iter)) {
		guint i;
		gtk_tree_model_get(model, &iter,
			DEV_NUM_COLUMN, &i,
			-1);
        
        chooser->_priv->cur_device = i;
        if (i >= 0) {
            GtkWidget *button = chooser->_priv->okbutton;
            gtk_widget_set_sensitive (button, TRUE);
        }
	}
}

static void
response_cb (GtkDialog *d, gint arg, gpointer userdata)
{
    GnomebtChooser *m = (GnomebtChooser *)userdata;
    switch (arg) {
        case GNOMEBT_RESPONSE_SCAN:
            g_signal_stop_emission_by_name ((gpointer)d,
                "response");
            gnomebt_chooser_start_scan (m);
            break;
        case GTK_RESPONSE_CANCEL:
        case GTK_RESPONSE_OK:
        case GTK_RESPONSE_DELETE_EVENT:
            m->_priv->response = arg;
            gtk_widget_hide (GTK_WIDGET (m));
            break;
        case GTK_RESPONSE_HELP:
            /* TODO -- do help*/
            break;
    }
}

static void
device_found_cb (GnomebtController *bc, gchar* device, gchar* name,
        gpointer data)
{
    GnomebtChooser *chooser = (GnomebtChooser *)data;
    g_message ("device %s %s found", device, name);
    gnomebt_chooser_populate_device_list (chooser);
}

static void
status_cb (GnomebtController *bc, gint field, gpointer data) {
    GnomebtChooser *chooser = GNOMEBT_CHOOSER (data);
    switch (field) {
        case BTCTL_STATUS_SCANNING:
            /* g_message("scanning started"); */
            break;
        case BTCTL_STATUS_GETTING_NAMES:
            /* g_message("getting names"); */
            break;
        case BTCTL_STATUS_GETTING_SERVICES:
            break;
        case BTCTL_STATUS_COMPLETE:
        case BTCTL_STATUS_ERROR:
            gtk_widget_set_sensitive (GTK_WIDGET(chooser->_priv->scanbutton),
                TRUE);
            /* g_message("scanning complete"); */
            break;
        default:
            break;
    }
}

%}
